% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jags.R, R/jags2.R, R/jagsParallel.R
\docType{class}
\name{jags}
\alias{jags}
\alias{rjags-class}
\alias{rjags.parallel-class}
\alias{jags2}
\alias{jags.parallel}
\title{Run \sQuote{JAGS} from R}
\usage{
jags(
  data,
  inits,
  parameters.to.save,
  model.file = "model.bug",
  n.chains = 3,
  n.iter = 2000,
  n.burnin = floor(n.iter/2),
  n.thin = max(1, floor((n.iter - n.burnin)/1000)),
  DIC = TRUE,
  pD = FALSE,
  n.iter.pd = NULL,
  n.adapt = 100,
  working.directory = NULL,
  jags.seed = 123,
  refresh = n.iter/50,
  progress.bar,
  digits = 5,
  RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),
  jags.module = c("glm", "dic"),
  quiet,
  checkMissing = FALSE
)

jags2(
  data,
  inits,
  parameters.to.save,
  model.file = "model.bug",
  n.chains = 3,
  n.iter = 2000,
  n.burnin = floor(n.iter/2),
  n.thin = max(1, floor((n.iter - n.burnin)/1000)),
  DIC = TRUE,
  jags.path = "",
  working.directory = NULL,
  clearWD = TRUE,
  refresh = n.iter/50
)

jags.parallel(
  data,
  inits,
  parameters.to.save,
  model.file = "model.bug",
  n.chains = 2,
  n.iter = 2000,
  n.burnin = floor(n.iter/2),
  n.thin = max(1, floor((n.iter - n.burnin)/1000)),
  n.cluster = n.chains,
  DIC = TRUE,
  working.directory = NULL,
  jags.seed = 123,
  digits = 5,
  RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),
  jags.module = c("glm", "dic"),
  export_obj_names = NULL,
  envir = .GlobalEnv
)
}
\arguments{
\item{data}{(1) a vector or list of the names of the data objects used by
the model, (2) a (named) list of the data objects themselves, or (3) the
name of a "dump" format file containing the data objects, which must end in
".txt", see example below for details.}

\item{inits}{a list with \code{n.chains} elements; each element of the list
is itself a list of starting values for the \code{BUGS} model, \emph{or} a
function creating (possibly random) initial values. If inits is
\code{NULL}, \code{JAGS} will generate initial values for parameters.}

\item{parameters.to.save}{character vector of the names of the parameters
to save which should be monitored.}

\item{model.file}{file containing the model written in \code{BUGS} code.
Alternatively, as in \pkg{R2WinBUGS}, \code{model.file} can be an R
function that contains a \code{BUGS} model that is written to a temporary
model file (see \code{tempfile}) using \code{write.model}}

\item{n.chains}{number of Markov chains (default: 3)}

\item{n.iter}{number of total iterations per chain (including burn in;
default: 2000)}

\item{n.burnin}{length of burn in, i.e. number of iterations to discard at
the beginning. Default is \code{n.iter/2}, that is, discarding the first
half of the simulations. If n.burnin is 0, \code{jags()} will run 100
iterations for adaption.}

\item{n.thin}{thinning rate. Must be a positive integer.  Set \code{n.thin}
> 1 to save memory and computation time if \code{n.iter} is large.  Default
is \code{max(1, floor(n.chains * (n.iter-n.burnin) / 1000))} which will
only thin if there are at least 2000 simulations.}

\item{DIC}{logical; if \code{TRUE} (default), compute deviance, pD, and
DIC. The rule \code{pD=var(deviance) / 2} is used.}

\item{pD}{logical; if \code{TRUE} and \code{DIC} is also \code{TRUE}, then
adds the computation of 'pD', using 'rjags::dic.samples()'. Defaults to
\code{FALSE}.}

\item{n.iter.pd}{number of iterations to feed 'rjags::dic.samples()' to
compute 'pD'. Defaults at 1000.}

\item{n.adapt}{number of iterations for which to run the adaptation, when
creating the model object. Defaults at 100.}

\item{working.directory}{sets working directory during execution of this
function; This should be the directory where model file is.}

\item{jags.seed}{random seed for \code{JAGS}, default is 123.  This
function is used for jags.parallell() and does not work for jags().  Use
set.seed() instead if you want to produce identical result with jags()}

\item{refresh}{refresh frequency for progress bar, default is
\code{n.iter/50}}

\item{progress.bar}{type of progress bar. Possible values are
\dQuote{text}, \dQuote{gui}, and \dQuote{none}. Type \dQuote{text} is
displayed on the R console. Type \dQuote{gui} is a graphical progress bar
in a new window. The progress bar is suppressed if \code{progress.bar} is
\dQuote{none}. Default set globally to \dQuote{text}}

\item{digits}{as in \code{\link{write.model}} in the \pkg{R2WinBUGS}
package: number of significant digits used for \code{BUGS} input, see
\code{\link{formatC}}.  Only used if specifying a \code{BUGS} model as an R
function.}

\item{RNGname}{the name for random number generator used in JAGS. There are
four RNGS supplied by the base moduale in JAGS: \code{Wichmann-Hill},
\code{Marsaglia-Multicarry}, \code{Super-Duper}, \code{Mersenne-Twister}}

\item{jags.module}{the vector of jags modules to be loaded.  Default are
\dQuote{glm} and \dQuote{dic}. Input NULL if you don't want to load any
jags module.}

\item{quiet}{Logical, whether to suppress stdout in \code{jags.model()}.
Default set globally to \dQuote{FALSE}}

\item{checkMissing}{Default: FALSE. When TRUE, checks for missing data in
categorical parameters and returns a \code{sim.list} with NA values if
detected. It's recommended to supply \code{jags()} with complete data.}

\item{jags.path}{directory that contains the \code{JAGS} executable.  The
default is \dQuote{}.}

\item{clearWD}{indicating whether the files \file{data.txt},
\file{inits[1:n.chains].txt}, \file{codaIndex.txt}, \file{jagsscript.txt},
and \file{CODAchain[1:nchains].txt} should be removed after \code{jags} has
finished, default=TRUE.}

\item{n.cluster}{number of clusters to use to run parallel chains.  Default
equals n.chains.}

\item{export_obj_names}{character vector of objects to export to the
clusters.}

\item{envir}{default is .GlobalEnv}
}
\description{
The \code{jags} function takes data and starting values as input.  It
automatically writes a \code{jags} script, calls the model, and saves the
simulations for easy access in R.
}
\details{
To run: \enumerate{ \item Write a \code{JAGS} model in an ASCII file.
\item Go into \R.  \item Prepare the inputs for the \code{jags} function
and run it (see Example section).  \item The model will now run in
\code{JAGS}. It might take awhile. You will see things happening in the R
console.  }

% BUGS version support: % \itemize{ % \item \pkg{jags} 1.0.3 {default} % }
}
\examples{
# Can set global options for some of the features of R2jags. For example
# running the command
options(r2j.pb="none")
# before launching jags shuts down the progress bar. Or running the command
options(r2j.quiet=FALSE)
# forces jags to not show the compilation summary. Or running the command
options(r2j.print.progam=FALSE)
# modifies the print method and prevents R2jags from printing the name of 
# software used to run the MCMC analysis. These options may be helpful 
# when using Rmarkdown or quarto to help formtting the output.
#
# An example model file is given in:
model.file <- system.file(package="R2jags", "model", "schools.txt")
# Let's take a look:
file.show(model.file)

#=================#
# Initialization  #
#=================#

# Data
J <- 8.0
y <- c(28.4, 7.9, -2.8, 6.8, -0.6, 0.6, 18.0, 12.2)
sd <- c(14.9, 10.2, 16.3, 11.0, 9.4, 11.4, 10.4, 17.6)

jags.data <- list(y = y, sd = sd, J = J)
jags.params <- c("mu", "sigma", "theta")
jags.inits <- function() {
  list(mu = rnorm(1), sigma = runif(1), theta = rnorm(J))
}

## You can input data in 4 ways:

# 1) Data as a list of character strings
jagsfit <- jags(data = list("y", "sd", "J"), inits = jags.inits, 
                parameters.to.save = jags.params, 
                n.iter = 10, model.file = model.file)

# 2) Data as a character vector of names
jagsfit <- jags(data = c("y", "sd", "J"), inits = jags.inits, 
                parameters.to.save = jags.params, 
                n.iter = 10, model.file = model.file)

# 3) Data as a named list
jagsfit <- jags(data = list(y = y, sd = sd, J = J), inits = jags.inits, 
                parameters.to.save = jags.params, 
                n.iter = 10, model.file = model.file)

# 4) Data from a file
fn <- "tmpbugsdata.txt"
dump(c("y", "sd", "J"), file = fn)
jagsfit <- jags(data = fn, inits = jags.inits, 
                parameters.to.save = jags.params, 
                n.iter = 10, model.file = model.file)
unlink("tmpbugsdata.txt")

## Writing a BUGS model as an R function
schoolsmodel <- function() {
  for (j in 1:J) {
    y[j] ~ dnorm(theta[j], tau.y[j])  # Likelihood
    tau.y[j] <- pow(sd[j], -2)        # Precision
  }
  for (j in 1:J) {
    theta[j] ~ dnorm(mu, tau)         # Hierarchical model
  }
  tau <- pow(sigma, -2)
  mu ~ dnorm(0.0, 1.0E-6)
  sigma ~ dunif(0, 1000)
}

jagsfit <- jags(data = jags.data, inits = jags.inits, 
                parameters.to.save = jags.params, 
                n.iter = 10, model.file = schoolsmodel)

#=================================#
# Running JAGS and postprocessing #
#=================================#

jagsfit <- jags(data = jags.data, inits = jags.inits, 
                parameters.to.save = jags.params, 
                n.iter = 5000, model.file = model.file)

## Computing DIC with pD
\dontrun{
jagsfit.pD <- jags(data = jags.data, inits = jags.inits, 
                   parameters.to.save = jags.params, 
                   n.iter = 5000, model.file = model.file, pD = TRUE)
}

## Running JAGS in parallel
\dontrun{
jagsfit.p <- jags.parallel(data = jags.data, inits = jags.inits, 
                            parameters.to.save = jags.params, 
                            n.iter = 5000, model.file = model.file)
print(jagsfit.p,digits=3,interval=c(0.025,0.975))
plot(jagsfit.p)
}

## Checking model convergence
\dontrun{
traceplot(jagsfit)
traceplot(jagsfit.p)
}

## Updating JAGS if the model does not converge
\dontrun{
jagsfit.upd <- update(jagsfit, n.iter = 100)
print(jagsfit.upd)
plot(jagsfit.upd)
}

## Auto-updating until convergence
\dontrun{
jagsfit.upd <- autojags(jagsfit)
jagsfit.upd <- autojags(jagsfit.p)
}

## Obtaining DIC separately
\dontrun{
dic.samples(jagsfit.upd$model, n.iter = 1000, type = "pD")
}

## Attaching and detaching JAGS results
\dontrun{
attach.jags(jagsfit.upd)
mu  # View parameter estimates
detach.jags()
}

## Picking up the last saved session
\dontrun{
recompile(jagsfit)
jagsfit.upd <- update(jagsfit, n.iter = 100)
}

}
\references{
Plummer, Martyn (2003) \dQuote{JAGS: A program for analysis of
Bayesian graphical models using Gibbs sampling.}
\url{https://www.r-project.org/conferences/DSC-2003/Proceedings/Plummer.pdf}.

Gelman, A., Carlin, J. B., Stern, H.S., Rubin, D.B. (2003) \emph{Bayesian
Data Analysis}, 2nd edition, CRC Press.

Sibylle Sturtz and Uwe Ligges and Andrew Gelman. (2005).
\dQuote{R2WinBUGS: A Package for Running WinBUGS from R.} \emph{Journal of
Statistical Software} 3 (12): 1--6.
}
\author{
Yu-Sung Su \email{suyusung@tsinghua.edu.cn}, Masanao Yajima
\email{yajima@bu.edu}, Gianluca Baio \email{g.baio@ucl.ac.uk}
}
\keyword{interface}
\keyword{models}
